Index: assignta.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>\"\"\"\nGabriella Montalvo & Maria Samos Rivas\nDS3500 Homework 6: Resource Allocation with Evolutionary Computing\nDue 11/23/25\nassignta.py\n\"\"\"\nimport pandas as pd\nimport random as rnd\nimport numpy as np\nfrom evo import Evo\n\n# OBJECTIVE 1\ndef overallocation(sol):\n    \"\"\"\n    Parameters:\n    Returns:\n    Does:\n    \"\"\"\n    assignments = sol['assignments']\n    tas = sol['tas']\n\n    # Counts how many sections a TA is assigned\n    assigned_section_count = np.sum(assignments, axis = 1)\n\n    # Gets the max number of allowed assignments for each TA\n    max_allowed = tas['max_assigned'].values\n\n    # Calculates the number of penalties, using vector math so negatives become 0\n    penalties = np.maximum(assigned_section_count - max_allowed, 0)\n    total_penalties = np.sum(penalties)\n\n    return total_penalties\n\n# OBJECTIVE 2\ndef conflicts(sol):\n    \"\"\"\n    Parameters:\n    Returns:\n    Does:\n    \"\"\"\n    assignments = sol['assignments']\n    sections = sol['sections']\n\n    time_conflicts_count = 0\n\n    # Loops over all TAs and their assignments\n    for i in range(assignments.shape[0]):\n        sections_assigned = np.where(assignments[i] == 1)[0]\n\n        # Collects all the meeting times for each lab section\n        section_times = sections.loc[sections_assigned, 'daytime'].values\n\n\n        # If length of unique times is less than the number of assigned sections, conflict exists!\n        if len(np.unique(section_times)) < len(section_times):\n            time_conflicts_count += 1\n\n    return time_conflicts_count\n\n# OBJECTIVE 3\ndef undersupport(sol):\n    \"\"\"\n    Parameters:\n    Return:\n    Does:\n    \"\"\"\n\n    assignments = sol['assignments']\n    sections = sol['sections']\n\n    assigned_section_count = np.sum(assignments, axis = 0)\n\n    # collects all values for the minimum number of tas per section\n    min_ta = sections['min_ta']\n\n    #  Calculates the number of penalties, using vector math so negatives become 0\n    penalties = np.maximum(min_ta - assigned_section_count, 0)\n    total_penalties = np.sum(penalties)\n\n    return total_penalties\n\n# OBJECTIVE 4\ndef unavailable(sol):\n    \"\"\"\n    Parameters:\n    Returns:\n    Does:\n    \"\"\"\n    assignments = sol['assignments']\n    tas = sol['tas']\n\n    availability_columns = [str(i) for i in range(assignments.shape[1])]\n    availability = tas[availability_columns].to_numpy()\n\n    # Checking the UNavailability of the TAs!\n    penalty = np.sum((assignments == 1) & (availability == 'U'))\n\n    return penalty\n\n# OBJECTIVE 5\ndef unpreferred(sol):\n    \"\"\"\n    Parameters:\n    Returns:\n    Does:\n    \"\"\"\n    assignments = sol['assignments']\n    availability = sol['tas'][[str(i) for i in range(assignments.shape[1])]].to_numpy()\n\n    # Checking if TAs preference is WILLING, a change from the previous objective\n    preference = np.sum((assignments == 1) & (availability == 'W'))\n\n    return preference\n\n# randomized initial solution\ndef inital_solutions():\n\n    tas = pd.read_csv(\"tas.csv\")\n    sections = pd.read_csv(\"sections.csv\")\n\n    avail_matrix = tas.iloc[:, 3:].to_numpy()\n    max_assigned_ta = tas[\"max_assigned\"].to_numpy()\n\n    num_tas, num_sections = avail_matrix.shape\n    assignments = np.zeros((num_tas, num_sections), dtype = int)\n\n    for i in range(num_tas):\n        allowed_sections = [j for j in range(num_sections) if avail_matrix[i, j] != 'U']\n        k = rnd.randint(0, max_assigned_ta[i])\n        k = min(k, len(allowed_sections))\n\n        chosen_sections = rnd.sample(allowed_sections, k)\n\n        for j in chosen_sections:\n            assignments[i, j] = 1\n\n    for j in range(num_sections):\n        current_tas = assignments[:, j].sum()\n        required_tas = sections['min_ta'].iloc[j]\n\n        while current_tas < required_tas:\n            candidates = [\n                i for i in range(num_tas)\n                if avail_matrix[i, j] != \"U\"\n                   and assignments[i, j] == 0\n                   and assignments[i, :].sum() < max_assigned_ta[i]\n            ]\n            if len(candidates) == 0:\n                break\n\n            i = rnd.choice(candidates)\n            assignments[i, j] = 1\n            current_tas += 1\n\n    return { \"assignments\": assignments, \"tas\": tas, \"sections\": sections }\n\ndef agent_fix_unavailable(parents):\n\n    sol = parents[0]\n    tas = sol['tas']\n    assignments = sol['assignments']\n\n    avail_matrix = tas.iloc[:, 3:].to_numpy()\n    num_tas, num_sections = assignments.shape\n\n    i = rnd.randint(0, num_tas - 1)\n    j = rnd.randint(0, num_sections - 1)\n\n    if assignments[i, j] == 1 and avail_matrix[i, j] == 'U':\n        assignments[i, j] = 0\n\n    return sol\n\ndef agent_fix_unpreferred(parents):\n\n    sol = parents[0]\n    tas = sol['tas']\n    assignments = sol['assignments']\n\n    avail_matrix = tas.iloc[:, 3:].to_numpy()\n    num_tas, num_sections = assignments.shape\n\n    i = rnd.randint(0, num_tas - 1)\n    j = rnd.randint(0, num_sections - 1)\n\n    if assignments[i, j] == 1 and avail_matrix[i, j] == 'W':\n        assignments[i, j] = 0\n\n    return sol\n\ndef agent_random_flip(parents):\n\n    sol = parents[0]\n    assignments = sol[\"assignments\"]\n\n    n_ta, n_sec = assignments.shape\n    i = rnd.randrange(0, n_ta)\n    j = rnd.randrange(0, n_sec)\n\n    assignments[i, j] = 1 - assignments[i, j]\n\n    return sol\n\ndef agent_reduce_overallocation(parents):\n\n    sol = parents[0]\n    tas = sol[\"tas\"]\n    assignments = sol[\"assignments\"]\n\n    max_assigned_ta = tas[\"max_assigned\"].to_numpy()\n\n    num_tas, num_sections = assignments.shape\n\n    i = rnd.randint(0, num_tas - 1)\n    assigned_sections = [j for j in range(num_sections) if assignments[i, j] == 1]\n\n    if len(assigned_sections) > max_assigned_ta[i]:\n        j = rnd.choice(assigned_sections)\n        assignments[i, j] = 0\n\n    return sol\n\n# Adding the objectives to evo!\nevo = Evo()\nevo.add_objective('overallocation', overallocation)\nevo.add_objective('conflicts', conflicts)\nevo.add_objective('undersupport', undersupport)\nevo.add_objective('unavailable', unavailable)\nevo.add_objective('unpreferred', unpreferred)\n\nfor _ in range(20):\n    evo.add_solution(inital_solutions())\n\n# Register agents\nevo.add_agent(\"fix_unavailable\", agent_fix_unavailable, k=1)\nevo.add_agent(\"fix_unpreferred\", agent_fix_unpreferred, k=1)\nevo.add_agent(\"random_flip\", agent_random_flip, k=1)\nevo.add_agent(\"reduce_overallocation\", agent_reduce_overallocation, k=1)\n\nprint(\"Initial nondominated population:\")\nprint(evo)\n\n# Run for 5 minutes\nevo.evolve(time_limit=300)\n\nprint(\"\\nFinal nondominated population:\")\nprint(evo)
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/assignta.py b/assignta.py
--- a/assignta.py	(revision 21bb1364eeac78cc14f6c1421d8f1c8f84e9133a)
+++ b/assignta.py	(date 1763932154607)
@@ -10,6 +10,7 @@
 from evo import Evo
 
 # OBJECTIVE 1
+
 def overallocation(sol):
     """
     Parameters:
